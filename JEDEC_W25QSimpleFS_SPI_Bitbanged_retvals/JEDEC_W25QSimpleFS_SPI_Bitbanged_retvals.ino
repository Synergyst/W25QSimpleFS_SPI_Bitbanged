// RP2040 + Winbond W25Q128, bit-banged SPI, simple FS + blob loader + console + autogen + core1 exec via mailbox.
// Pins:
//   Pin 0 -> MISO
//   Pin 1 -> CS
//   Pin 2 -> SCK
//   Pin 3 -> MOSI
#include "pico/stdlib.h"    // tight_loop_contents(), etc.
#include "pico/platform.h"  // for __scratch_x()
#include <Arduino.h>
#include "W25QBitbang.h"
#include "W25QSimpleFS.h"

// ================== Hardcoded binary blobs ==================
#include "blob_mailbox_config.h"  // Mailbox config generated by Makefile
#include "blob_add2.h"
#include "blob_ret42.h"
#include "blob_square.h"
#include "blob_gpio_pwm_cycles.h"

// ================== Target filenames (must be <= 32 chars; FS name limit) ==================
#define FILE_RET42 "ret42"
#define FILE_ADD2 "add2"
#define FILE_SQUARE "square"
#define FILE_PWMC "pwmc"

// ================== Bitbang SPI flash filesystem ==================
const uint8_t PIN_MISO = 0;
const uint8_t PIN_CS = 1;
const uint8_t PIN_SCK = 2;
const uint8_t PIN_MOSI = 3;
W25QBitbang flash(PIN_MISO, PIN_CS, PIN_SCK, PIN_MOSI);
W25QSimpleFS fs(flash);

// ================== Mailbox reservation (Scratch) ==================
// Reserve mailbox in Scratch X (0x20040000..0x20040FFF)
extern "C" __scratch_x("blob_mailbox") __attribute__((aligned(4)))
uint8_t BLOB_MAILBOX[BLOB_MAILBOX_MAX] = { 0 };

// ================== Blob registry (compiled-in arrays) ==================
struct BlobReg {
  const char* id;       // console id (e.g., "ret42")
  const uint8_t* data;  // array from header
  unsigned int len;     // length from header
};
static const BlobReg g_blobs[] = {
  { FILE_RET42, blob_ret42, blob_ret42_len },
  { FILE_ADD2, blob_add2, blob_add2_len },
  { FILE_SQUARE, blob_square, blob_square_len },
  { FILE_PWMC, blob_gpio_pwm_cycles, blob_gpio_pwm_cycles_len },
};
static const size_t g_blobs_count = sizeof(g_blobs) / sizeof(g_blobs[0]);
static void printHexByte(uint8_t b) {
  if (b < 0x10) Serial.print('0');
  Serial.print(b, HEX);
}
static volatile uint32_t g_timeout_override_ms = 0;  // Timeout override (0 = use per-call defaults)
static inline uint32_t getTimeout(uint32_t defMs) {
  return g_timeout_override_ms ? g_timeout_override_ms : defMs;
}

// ================== Core1 execution plumbing (mailbox) ==================
typedef int (*fn4_t)(int, int, int, int);
struct ExecJob {
  uintptr_t code;  // raw aligned code address (LSB 0)
  uint32_t size;   // code size (bytes, even)
  int32_t a;
  int32_t b;
  int32_t c;
  int32_t d;
};

// ================== Shared mailbox ==================
static volatile ExecJob g_job;
static volatile int32_t g_result = 0;
static volatile int32_t g_status = 0;
static volatile uint32_t g_job_flag = 0;  // Job flag: 0=idle, 1=ready, 2=running, 3=done
static void core1WorkerPoll() {
  // Core1 worker poll (called from loop1())
  if (g_job_flag != 1u) return;

  __asm volatile("dsb" ::
                   : "memory");
  __asm volatile("isb" ::
                   : "memory");

  g_job_flag = 2u;

  ExecJob job;
  job.code = g_job.code;
  job.size = g_job.size;
  job.a = g_job.a;
  job.b = g_job.b;
  job.c = g_job.c;
  job.d = g_job.d;

  int32_t rv = 0;
  int32_t st = 0;

  if (job.code == 0 || (job.size & 1u)) {
    st = -1;  // invalid entry
  } else {
    void* entryThumb = (void*)(job.code | 1u);
    fn4_t fn = (fn4_t)entryThumb;
    rv = fn(job.a, job.b, job.c, job.d);
  }

  g_result = rv;
  g_status = st;

  __asm volatile("dsb" ::
                   : "memory");
  __asm volatile("isb" ::
                   : "memory");

  g_job_flag = 3u;
}
static bool runOnCore1(uintptr_t codeAligned, uint32_t sz, int32_t a, int32_t b, int32_t c, int32_t d, int& retVal, uint32_t timeoutMs = 100) {
  // Core0 helper: run already-loaded RAM code on core1, return result.
  if (g_job_flag != 0u) {
    Serial.println("core1 busy");
    return false;
  }

  g_job.code = codeAligned;
  g_job.size = sz;
  g_job.a = a;
  g_job.b = b;
  g_job.c = c;
  g_job.d = d;
  g_status = 0;
  g_result = 0;

  __asm volatile("dsb" ::
                   : "memory");
  __asm volatile("isb" ::
                   : "memory");

  g_job_flag = 1u;

  uint32_t start = millis();
  while (g_job_flag != 3u) {
    tight_loop_contents();
    if ((millis() - start) > timeoutMs) {
      Serial.println("core1 timeout");
      return false;
    }
  }

  if (g_status != 0) {
    Serial.print("core1 error status=");
    Serial.println((int)g_status);
    g_job_flag = 0u;
    return false;
  }

  retVal = (int)g_result;
  g_job_flag = 0u;
  return true;
}

// ================== FS helpers and console ==================
static bool checkNameLen(const char* name) {
  size_t n = strlen(name);
  if (n == 0 || n > fs.MAX_NAME) {
    Serial.print("Error: filename length ");
    Serial.print(n);
    Serial.print(" exceeds max ");
    Serial.print(fs.MAX_NAME);
    Serial.println(". Use a shorter name (e.g., mulA.bin, mulB.bin).");
    return false;
  }
  return true;
}
static void listBlobs() {
  Serial.println("Available blobs:");
  for (size_t i = 0; i < g_blobs_count; ++i) {
    Serial.print(" - ");
    Serial.print(g_blobs[i].id);
    Serial.print(" (");
    Serial.print(g_blobs[i].len);
    Serial.println(" bytes)");
  }
}
static const BlobReg* findBlob(const char* id) {
  for (size_t i = 0; i < g_blobs_count; ++i) {
    if (strcmp(g_blobs[i].id, id) == 0) return &g_blobs[i];
  }
  return nullptr;
}
static void dumpFileHead(const char* fname, uint32_t count) {
  uint32_t sz = 0;
  if (!fs.getFileSize(fname, sz) || sz == 0) {
    Serial.println("dump: missing/empty");
    return;
  }
  if (count > sz) count = sz;

  const size_t CHUNK = 32;
  uint8_t buf[CHUNK];
  uint32_t off = 0;

  Serial.print(fname);
  Serial.print(" size=");
  Serial.println(sz);

  while (off < count) {
    size_t n = (count - off > CHUNK) ? CHUNK : (count - off);
    fs.readFileRange(fname, off, buf, n);
    Serial.print("  ");
    for (size_t i = 0; i < n; ++i) {
      if (i) Serial.print(' ');
      printHexByte(buf[i]);
    }
    Serial.println();
    off += n;
  }
}
static bool loadFileToExecBuf(const char* fname, void*& rawOut, uint8_t*& alignedBuf, uint32_t& szOut) {
  // Load file fully into an aligned RAM buffer suitable for execution.
  rawOut = nullptr;
  alignedBuf = nullptr;
  szOut = 0;

  uint32_t sz = 0;
  if (!fs.getFileSize(fname, sz) || sz == 0) {
    Serial.println("load: file missing/empty");
    return false;
  }
  if (sz & 1u) {
    Serial.println("load: odd-sized blob (Thumb requires 16-bit alignment)");
    return false;
  }

  void* raw = malloc(sz + 4);
  if (!raw) {
    Serial.println("load: malloc failed");
    return false;
  }
  uint8_t* buf = (uint8_t*)((((uintptr_t)raw) + 3) & ~((uintptr_t)3));

  if (fs.readFile(fname, buf, sz) != sz) {
    Serial.println("load: read failed");
    free(raw);
    return false;
  }

  rawOut = raw;
  alignedBuf = buf;
  szOut = sz;
  return true;
}
static bool ensureBlobFile(const char* fname, const uint8_t* data, uint32_t len, uint32_t reserve = fs.SECTOR_SIZE) {
  // Create/Update a file with a blob (manual path: create slot if not present, in-place update if possible)
  if (!checkNameLen(fname)) return false;

  if (!fs.exists(fname)) {
    Serial.print("Creating slot ");
    Serial.print(fname);
    Serial.print(" (");
    Serial.print(reserve);
    Serial.println(" bytes)...");
    if (fs.createFileSlot(fname, reserve, data, len)) {
      Serial.println("Created and wrote blob");
      return true;
    } else {
      Serial.println("Failed to create slot");
      return false;
    }
  }

  uint32_t addr, size, cap;
  if (!fs.getFileInfo(fname, addr, size, cap)) {
    Serial.println("getFileInfo failed");
    return false;
  }

  bool same = (size == len);
  if (same) {
    const size_t CHUNK = 64;
    uint8_t buf[CHUNK];
    uint32_t off = 0;
    while (off < size) {
      size_t n = (size - off > CHUNK) ? CHUNK : (size - off);
      fs.readFileRange(fname, off, buf, n);
      for (size_t i = 0; i < n; ++i) {
        if (buf[i] != data[off + i]) {
          same = false;
          break;
        }
      }
      if (!same) break;
      off += n;
      yield();
    }
  }

  if (same) {
    Serial.println("Blob already up to date");
    return true;
  }

  if (cap >= len && fs.writeFileInPlace(fname, data, len)) {
    Serial.println("Updated in place");
    return true;
  }

  if (fs.writeFile(fname, data, len, W25QSimpleFS::WriteMode::ReplaceIfExists)) {
    Serial.println("Updated by allocating new space");
    return true;
  }

  Serial.println("Failed to update file");
  return false;
}
static bool ensureBlobIfMissing(const char* fname, const uint8_t* data, uint32_t len, uint32_t reserve = fs.SECTOR_SIZE) {
  // Auto-write ONLY IF MISSING (does not update if present)
  if (!checkNameLen(fname)) return false;
  if (fs.exists(fname)) {
    Serial.print(fname);
    Serial.println(" present (skipping)");
    return true;
  }
  Serial.print("Auto-creating ");
  Serial.print(fname);
  Serial.print(" (");
  Serial.print(reserve);
  Serial.println(" bytes)...");
  if (fs.createFileSlot(fname, reserve, data, len)) {
    Serial.println("Created and wrote blob");
    return true;
  }
  Serial.println("Auto-create failed");
  return false;
}
static void autogenBlobWrites() {
  // Call this to auto-create only the blobs you enabled with #defines above
  bool allOk = true;
  allOk &= ensureBlobIfMissing(FILE_RET42, blob_ret42, blob_ret42_len);
  allOk &= ensureBlobIfMissing(FILE_ADD2, blob_add2, blob_add2_len);
  allOk &= ensureBlobIfMissing(FILE_SQUARE, blob_square, blob_square_len);
  allOk &= ensureBlobIfMissing(FILE_PWMC, blob_gpio_pwm_cycles, blob_gpio_pwm_cycles_len);
  Serial.print("autogen: ");
  Serial.println(allOk ? "OK" : "some failures");
}

// ================== Mailbox helpers ==================
static inline void mailboxClearFirstByte() {
  volatile uint8_t* mb = (volatile uint8_t*)(uintptr_t)BLOB_MAILBOX_ADDR;
  mb[0] = 0;  // sentinel
}
static void mailboxPrintIfAny() {
  const volatile char* p = (const volatile char*)(uintptr_t)BLOB_MAILBOX_ADDR;
  if (p[0] == '\0') return;  // nothing written
  Serial.print(" Info=\"");
  for (size_t i = 0; i < BLOB_MAILBOX_MAX; ++i) {
    char c = p[i];
    if (!c) break;
    Serial.print(c);
  }
  Serial.println("\"");
}

// ================== Execution helpers ==================
static char lineBuf[fs.SECTOR_SIZE];
static bool execBlobGeneric(const char* fname, int argc, const int argv[], int& retVal) {
  // Generic exec: runs blob with 0..4 integer args, handles mailbox clear/print.
  if (argc < 0) argc = 0;
  if (argc > 4) argc = 4;

  void* raw = nullptr;
  uint8_t* buf = nullptr;
  uint32_t sz = 0;
  if (!loadFileToExecBuf(fname, raw, buf, sz)) return false;

  mailboxClearFirstByte();

  uintptr_t code = (uintptr_t)buf;  // aligned buffer address
  Serial.print("Calling entry on core1 at 0x");
  Serial.println((uintptr_t)buf, HEX);

  // Always pass 4 args; zero-fill the rest.
  int a = (argc > 0) ? argv[0] : 0;
  int b = (argc > 1) ? argv[1] : 0;
  int c = (argc > 2) ? argv[2] : 0;
  int d = (argc > 3) ? argv[3] : 0;

  bool ok = runOnCore1(code, sz, a, b, c, d, retVal, getTimeout(100000));
  if (!ok) {
    Serial.println("exec: core1 run failed");
    free(raw);
    return false;
  }

  Serial.print("Return=");
  Serial.println(retVal);
  mailboxPrintIfAny();

  free(raw);
  return true;
}
static int nextToken(char*& p, char*& tok) {
  // Skip spaces/tabs/newlines
  while (*p && (*p == ' ' || *p == '\t' || *p == '\r' || *p == '\n')) ++p;
  if (!*p) {
    tok = nullptr;
    return 0;
  }
  tok = p;
  while (*p && *p != ' ' && *p != '\t' && *p != '\r' && *p != '\n') ++p;
  if (*p) {
    *p = 0;
    ++p;
  }
  return 1;
}
static bool readLine() {
  static size_t pos = 0;
  while (Serial.available()) {
    char c = (char)Serial.read();
    if (c == '\r') continue;
    if (c == '\n') {
      lineBuf[pos] = 0;
      pos = 0;
      return true;
    }
    if (pos + 1 < sizeof(lineBuf)) lineBuf[pos++] = c;
  }
  return false;
}
static void printHelp() {
  Serial.println("Commands (filename max 32 chars):");
  Serial.println("  help                         - this help");
  Serial.println("  blobs                        - list compiled-in blobs");
  Serial.println("  autogen                      - auto-create enabled blobs if missing");
  Serial.println("  files                        - list files in FS");
  Serial.println("  info <file>                  - show file addr/size/cap");
  Serial.println("  dump <file> <nbytes>         - hex dump head of file");
  Serial.println("  mkSlot <file> <reserve>      - create sector-aligned slot");
  Serial.println("  writeblob <file> <blobId>    - create/update file from blob");
  Serial.println("  exec <file> [a [b [c [d]]]]  - execute blob with 0..4 int args on core1");
  Serial.println("  timeout [ms]                 - show or set core1 timeout override (0=defaults)");
  Serial.println();
}
static void handleCommand(char* line) {
  char* p = line;
  char* t0;
  if (!nextToken(p, t0)) return;

  if (!strcmp(t0, "help")) {
    printHelp();

  } else if (!strcmp(t0, "reboot")) {
    rp2040.reboot();

  } else if (!strcmp(t0, "meminfo")) {
    Serial.println();
    Serial.printf("Total Heap:        %d bytes\n", rp2040.getTotalHeap());
    Serial.printf("Free Heap:         %d bytes\n", rp2040.getFreeHeap());
    Serial.printf("Used Heap:         %d bytes\n", rp2040.getUsedHeap());
    Serial.printf("Total PSRAM Heap:  %d bytes\n", rp2040.getTotalPSRAMHeap());
    Serial.printf("Free PSRAM Heap:   %d bytes\n", rp2040.getFreePSRAMHeap());
    Serial.printf("Used PSRAM Heap:   %d bytes\n", rp2040.getUsedPSRAMHeap());
    Serial.printf("Free Stack:        %d bytes\n", rp2040.getFreeStack());

  } else if (!strcmp(t0, "blobs")) {
    listBlobs();

  } else if (!strcmp(t0, "autogen")) {
    autogenBlobWrites();

  } else if (!strcmp(t0, "files")) {
    fs.listFilesToSerial();

  } else if (!strcmp(t0, "info")) {
    char* fn;
    if (!nextToken(p, fn)) {
      Serial.println("usage: info <file>");
      return;
    }
    uint32_t a, s, c;
    if (fs.getFileInfo(fn, a, s, c)) {
      Serial.print(fn);
      Serial.print(": addr=0x");
      Serial.print(a, HEX);
      Serial.print(" size=");
      Serial.print(s);
      Serial.print(" cap=");
      Serial.println(c);
    } else {
      Serial.println("not found");
    }

  } else if (!strcmp(t0, "dump")) {
    char* fn;
    char* nstr;
    if (!nextToken(p, fn) || !nextToken(p, nstr)) {
      Serial.println("usage: dump <file> <nbytes>");
      return;
    }
    dumpFileHead(fn, (uint32_t)strtoul(nstr, nullptr, 0));

  } else if (!strcmp(t0, "mkSlot")) {
    char* fn;
    char* nstr;
    if (!nextToken(p, fn) || !nextToken(p, nstr)) {
      Serial.println("usage: mkSlot <file> <reserve>");
      return;
    }
    if (!checkNameLen(fn)) return;
    uint32_t res = (uint32_t)strtoul(nstr, nullptr, 0);
    if (fs.createFileSlot(fn, res, nullptr, 0)) Serial.println("slot created");
    else Serial.println("mkSlot failed");

  } else if (!strcmp(t0, "writeblob")) {
    char* fn;
    char* bid;
    if (!nextToken(p, fn) || !nextToken(p, bid)) {
      Serial.println("usage: writeblob <file> <blobId>");
      return;
    }
    if (!checkNameLen(fn)) return;
    const BlobReg* br = findBlob(bid);
    if (!br) {
      Serial.println("unknown blobId; use 'blobs'");
      return;
    }
    if (ensureBlobFile(fn, br->data, br->len)) Serial.println("writeblob OK");
    else Serial.println("writeblob failed");

  } else if (!strcmp(t0, "exec")) {
    char* fn;
    if (!nextToken(p, fn)) {
      Serial.println("usage: exec <file> [a [b [c [d]]]]");
      return;
    }
    int argv4[4] = { 0, 0, 0, 0 };
    int argc = 0;
    char* tok;
    while (argc < 4 && nextToken(p, tok)) {
      argv4[argc++] = (int)strtol(tok, nullptr, 0);
    }
    int rv;
    if (!execBlobGeneric(fn, argc, argv4, rv)) {
      Serial.println("exec failed");
    }

  } else if (!strcmp(t0, "del")) {
    char* fn;
    if (!nextToken(p, fn)) {
      Serial.println("usage: del <file>");
      return;
    }
    if (fs.deleteFile(fn)) Serial.println("deleted");
    else Serial.println("delete failed");

  } else if (!strcmp(t0, "format")) {
    if (fs.format()) Serial.println("FS formatted");
    else Serial.println("format failed");

  } else if (!strcmp(t0, "wipebootloader")) {
    Serial.println("Erasing entire chip... this can take a while");
    if (fs.wipeChip()) {
      Serial.println("Chip wiped, rebooting to bootloader now..");
      rp2040.rebootToBootloader();
    } else {
      Serial.println("wipe failed");
    }

  } else if (!strcmp(t0, "wipereboot")) {
    Serial.println("Erasing entire chip... this can take a while");
    if (fs.wipeChip()) {
      Serial.println("Chip wiped, rebooting now..");
      rp2040.reboot();
    } else {
      Serial.println("wipe failed");
    }

  } else if (!strcmp(t0, "wipe")) {
    Serial.println("Erasing entire chip... this can take a while");
    if (fs.wipeChip()) Serial.println("Chip wiped");
    else Serial.println("wipe failed");

  } else if (!strcmp(t0, "timeout")) {
    char* msStr;
    if (!nextToken(p, msStr)) {
      Serial.print("timeout override = ");
      Serial.print((uint32_t)g_timeout_override_ms);
      Serial.println(" ms (0 = use per-call defaults)");
      return;
    }
    uint32_t ms = (uint32_t)strtoul(msStr, nullptr, 0);
    g_timeout_override_ms = ms;
    Serial.print("timeout override set to ");
    Serial.print(ms);
    Serial.println(" ms");

  } else {
    Serial.println("Unknown command. Type 'help'.");
  }
}

void setup() {
  Serial.begin(115200);
  while (!Serial) {}
  delay(5);

  // Verify mailbox placement is inside Scratch X window
  uintptr_t actual = (uintptr_t)BLOB_MAILBOX;
  uintptr_t expect = (uintptr_t)BLOB_MAILBOX_ADDR;  // now 0x20040000
  constexpr uintptr_t SCRATCH_X_SIZE = 4096;        // 4KB

  if (!(actual >= expect && (actual + BLOB_MAILBOX_MAX) <= (expect + SCRATCH_X_SIZE))) {
    Serial.println("WARNING: Mailbox not fully inside expected Scratch X range.");
    Serial.print("  Expect range: 0x");
    Serial.print(expect, HEX);
    Serial.print(" .. 0x");
    Serial.println(expect + SCRATCH_X_SIZE - 1, HEX);
    Serial.print("  Actual addr:  0x");
    Serial.println(actual, HEX);
  } else {
    Serial.print("Reserved mailbox at 0x");
    Serial.print(actual, HEX);
    Serial.print(" size ");
    Serial.println((unsigned)BLOB_MAILBOX_MAX);
  }

  // Clear mailbox
  for (size_t i = 0; i < BLOB_MAILBOX_MAX; ++i) BLOB_MAILBOX[i] = 0;

  flash.begin();
  uint8_t mfr, memType, capCode;
  uint32_t capacityBytes = flash.readJEDEC(mfr, memType, capCode);
  Serial.print("JEDEC ID: ");
  printHexByte(mfr);
  Serial.print(' ');
  printHexByte(memType);
  Serial.print(' ');
  printHexByte(capCode);
  Serial.print("  Capacity: ");
  Serial.print(capacityBytes);
  Serial.println(" bytes");

  if (!fs.mount(true)) {
    Serial.println("FS mount failed");
    return;
  }

  Serial.println("Initial listing:");
  fs.listFilesToSerial();
  fs.setAlignToPageBoundary(false);  // packing preference for append-only writes

  autogenBlobWrites();  // Automatically generate blob binaries to SPI flash from hard-coded examples

  Serial.println();
  printHelp();
  Serial.println();
  listBlobs();
  Serial.println();
  Serial.print("> ");
}
void setup1() {
  g_job_flag = 0u;  // Start idle
}
void loop1() {
  core1WorkerPoll();      // Poll mailbox; returns immediately if no job
  tight_loop_contents();  // Power-friendly idle
}
void loop() {
  if (readLine()) {
    handleCommand(lineBuf);
    Serial.print("> ");
  }
}
